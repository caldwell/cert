#!/usr/bin/env ruby

require 'yaml'
require 'fileutils'
require 'openssl'

$my_dir = File.dirname($0)
$conf_dir = $my_dir

require 'shell'
require File.join $my_dir,'verbose-shell.rb'
Sh=Shell.new
Vsh = VerboseShell

require 'optparse'
(opts=OptionParser.new do |opts|
   opts.banner = "Usage:\n\t#{$0} [options]"
   opts.on("-v", "--verbose",              "Turn up the verbosity")                                     { |v| $verbose = (($verbose||0))+1 }
   opts.on("-n", "--dry-run",              "Don't really do anything")                                  { |d| $dryrun = true }
   opts.on("-c", "--config CONFDIR",       "Use this config dir (default: #{$conf_dir})")               { |d| $conf_dir = d }
   opts.on("--staging",                    "Use the letsencrypt staging CA")                            { |s| $staging = "https://acme-staging.api.letsencrypt.org" }
 end).parse!

$certs_dir = "#{$conf_dir}/certs"

Vsh.verbose = ($verbose||0) > 1

def load_config(file)
  config = YAML.load_file(file)

  (config["include"]||[]).map { |file| load_config(file) }.reduce(config) { |config, c| config.merge(c) }
end

def file(info, type, format="pem")
  "#{$certs_dir}/#{info['year']}/#{info['name']}-#{info['date']}.#{type}.#{format}"
end

def file_master(info, type, format="pem")
  "#{$certs_dir}/#{info['name']}.#{type}.#{format}"
end

def parse_time_from_filename(name)
  raise "no date found in #{name}" unless m = name.match(/(20\d\d)-([01]\d)-([0123]\d)/)
  Time.new(m[1],m[2],m[3])
end

def generate_csr(info)
  puts "generating key + csr: #{file(info,"key")}, #{file(info,"csr")}" if ($verbose||0) == 1
  return if $dryrun
  Vsh.mkdir_p File.dirname(file(info,"key"))
  Vsh.system(*%W"#{$my_dir}/new-csr #{file(info,"key")} #{file(info,"csr")}
                    --hash=#{info["HASH"]        || $config["HASH"]}
                    --bits=#{info["RSA_BITS"]    || $config["RSA_BITS"]}
                    --days=#{info["EXPIRE_DAYS"] || $config["EXPIRE_DAYS"]}"+
             %w"country state locality organization section cn email".map {|p| info[p] && "--#{p}=#{info[p]}" }.select {|s| s}+
             (info['alt'] ? info['alt'].map {|a| a['DNS'] }.select {|a| a}.map {|a| "--alt-dns=#{a}" } : [])
            )
  Vsh.chown info['user'], info['group'], file(info,"key")
end

def generate_cert(info)
  puts "generating cert: #{file(info,"cert")}" if ($verbose||0) == 1
  return if $dryrun
  (well_known_host, well_known_dir) = [$1,$2] if (info['well-known']||'') =~ /^(?:((?:\w+@)?[^:]+):)?(.+)$/
  well_known_dir ||= '/var/www/well-known/acme-challenge/'
  Vsh.system *(%W<python #{$my_dir}/acme-tiny/acme_tiny.py --chain --account-key #{$my_dir}/letsencrypt-account.key --csr #{file(info,"csr")} --acme-dir #{well_known_dir} --out #{file(info,"cert")}> +
               ($staging ? ['--ca', $staging] : []) +
               (well_known_host ? ['--acme-host', well_known_host] : []))
end

def generate_combined_cert(info)
  puts "generating combined cert: #{file(info,"combined")}" if ($verbose||0) == 1
  return if $dryrun
  IO.write(file(info,"combined"), IO.read(file(info,"cert")) + IO.read(file(info,"key")), perm: 0640)
  Vsh.chown info['user'], info['group'], file(info,"combined")
end

def generate_fingerprint(info)
  puts "generating fingerprint: #{file(info,"cert","fingerprint")}" if ($verbose||0) == 1
  return if $dryrun
  Sh.system(*%W"openssl x509 -in #{file(info,"cert")} -fingerprint -noout") > file(info,"cert","fingerprint")
end

def generate_der(info)
  puts "generating der: #{file(info,"key","der")}, #{file(info,"cert","der")}" if ($verbose||0) == 1
  return if $dryrun
  Vsh.system *%W"openssl x509 -in #{file(info,"cert")} -outform der -out #{file(info,"cert","der")}"
  Vsh.system *%W"openssl rsa  -in #{file(info,"key") } -outform der -out #{file(info,"key", "der")}"
  Vsh.chmod "o-rw,g-w", file(info,"key","der")
  Vsh.chown info['user'], info['group'], file(info,"key","der")
end

def scp_certs(info, file_params)
  files_to_copy = file_params.map { |p| file_master(info,*p) }
                  .select { |f| File.mtime(f) > (File.mtime("#{f}.scp-stamp") rescue Time.new(0)) }
  return unless files_to_copy.count > 0
  puts "copying #{files_to_copy}: #{info['scp']}" if ($verbose||0) == 1
  return if $dryrun
  Vsh.system 'scp', *files_to_copy, info['scp']
  Vsh.system 'touch', *(files_to_copy.map { |f| "#{f}.scp-stamp" })
end

def seconds_til_expiry(file)
  OpenSSL::X509::Certificate.new(File.read file).not_after - Time.now
end
def days_til_expiry(file)
  seconds_til_expiry(file) / 3600 / 24
end

def shortest_link_path(src, dst)
  src = File.absolute_path(src)
  dst = File.absolute_path(dst)
  sa = src.split(File::SEPARATOR)
  da = dst.split(File::SEPARATOR)
  while sa[0] == da[0]
    sa.shift
    da.shift
  end
  [sa.join(File::SEPARATOR), da.join(File::SEPARATOR)]
end

conf_file = "#{$conf_dir}/config.yaml"
$config = load_config(conf_file)

$config.select {|k,v| v.class == Hash}.each do |name, info|
  info['name'] = name
  puts "Considering: #{info.inspect}"  if ($verbose||0) > 2
  certfile = file_master(info,"cert")
  renew = File.exist?(certfile) && days_til_expiry(certfile) < 10
  time = File.exist?(certfile) && !renew ? parse_time_from_filename(File.readlink(certfile)) : Time.now
  puts "Needs renewal: #{certfile}, expires in #{days_til_expiry(certfile)} days" if renew && ($verbose||0) > 1
  info['date'] = time.strftime("%Y-%m-%d")
  info['year'] = time.strftime("%Y")
  success = true
  files = ([
    [ :generate_csr,           [["key"],["csr"]],               true ],
    [ :generate_cert,          [["cert"]],                      true ],
    [ :generate_combined_cert, [["combined"]],                  info['combined'] ],
    [ :generate_fingerprint,   [["cert", "fingerprint"]],       info['fingerprint'] ],
    [ :generate_der,           [["cert", "der"],["key","der"]], info['der'] ],
  ].map do |method, file_param, doit|
    next unless doit
    begin
      send(method, info) unless file_param.map { |p| file(info, *p) }.all? {|file| File.exist?(file) }
    rescue => e
      warn e
      success = false
      break
    end
    file_param
  end||[]).select { |fp| fp }.each do |files|
    files.each do |file_param|
      link = file_master(info, *file_param)
      master = file(info, *file_param)
      next if File.exist?(link) && File.absolute_path(File.readlink(link), $certs_dir) == File.absolute_path(master)
      (master,) = shortest_link_path(master, link)
      puts "#{link} -> #{master}" if ($verbose||0) == 1
      next if $dryrun
      Vsh.unlink(link) rescue nil
      Vsh.ln_s(master, link)
    end
  end.flatten(1)
  scp_certs(info, files) if info['scp']
  Vsh.system(info['on_renew']) if success && renew && info['on_renew']
end

#require 'pp'

#pp $config

